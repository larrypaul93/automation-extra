{"version":3,"file":"index.cjs.js","sources":["../src/index.ts"],"sourcesContent":["import debug, { Debugger } from 'debug'\n\nimport { EventEmitter } from 'events'\nimport TypedEmitter from 'typed-emitter'\n\nimport type * as Playwright from 'playwright-core'\nimport type * as Puppeteer from 'puppeteer'\nexport type { Puppeteer, Playwright } // Re-export\n\nimport type { ProtocolConnectionBase } from '@tracerbench/protocol-connection'\n\n// We use dummy/noop functions in PluginLifecycleMethods meant to be overriden\n/* tslint:disable:no-empty */\n\n/** @private */\nconst merge = require('deepmerge')\nimport { isPlainObject } from 'is-plain-object'\nconst mergeOptions = { isMergeableObject: isPlainObject }\n\nexport interface PluginOptions {\n  [key: string]: any\n}\n\n/** Like `Partial<>` but with nested property support */\nexport type NestedPartial<T> = {\n  [K in keyof T]?: T[K] extends Array<infer R>\n    ? Array<NestedPartial<R>>\n    : NestedPartial<T[K]>\n}\n\n// Let the plugin know the context of things\nexport interface LaunchContext {\n  context: 'launch' | 'connect'\n  isHeadless: boolean\n  options: Puppeteer.LaunchOptions | Playwright.LaunchOptions | any\n}\n\nexport type PluginDependencies = Set<string> | Map<string, any>\nexport type PluginRequirements = Set<'launch' | 'headful' | 'runLast'>\n\nexport type LaunchOptions = Puppeteer.LaunchOptions | Playwright.LaunchOptions\nexport type ConnectOptions =\n  | Puppeteer.ConnectOptions\n  | Playwright.ConnectOptions\nexport type Browser = Puppeteer.Browser | Playwright.Browser\nexport type Page = Puppeteer.Page | Playwright.Page\nexport type Worker = Puppeteer.Worker | Playwright.Worker\n\n/**\n * Minimal plugin interface\n * @private\n */\nexport interface MinimalPlugin {\n  _isAutomationExtraPlugin: boolean\n  [propName: string]: any\n}\n\n/**\n * Filters\n * @private\n */\nexport type FilterString =\n  | 'playwright:chromium'\n  | 'playwright:firefox'\n  | 'playwright:webkit'\n  | 'puppeteer:chromium'\n  | 'puppeteer:firefox'\n\nexport interface FilterInclude {\n  include: FilterString[]\n  exclude?: never\n}\nexport interface FilterExclude {\n  include?: never\n  exclude: FilterString[]\n}\nexport type Filter = FilterInclude | FilterExclude\n\n/**\n * Plugin lifecycle methods used by AutomationExtraPlugin.\n *\n * These are hooking into Playwright/Puppeteer events and are meant to be overriden\n * on a per-need basis in your own plugin extending AutomationExtraPlugin.\n *\n * @class PluginLifecycleMethods\n */\nexport class PluginLifecycleMethods {\n  /**\n   * After the plugin has been registered, called early in the life-cycle (once the plugin has been added).\n   */\n  async onPluginRegistered(): Promise<void> {}\n  /**\n   * Before a new browser instance is created/launched.\n   *\n   * Can be used to modify the puppeteer/playwright launch options by modifying or returning them.\n   *\n   * Plugins using this method will be called in sequence to each\n   * be able to update the launch options.\n   *\n   * @example\n   * async beforeLaunch (options) {\n   *   if (this.opts.flashPluginPath) {\n   *     options.args = options.args || []\n   *     options.args.push(`--ppapi-flash-path=${this.opts.flashPluginPath}`)\n   *   }\n   * }\n   *\n   * @param options - Puppeteer/Playwright launch options\n   */\n  async beforeLaunch(options: LaunchOptions): Promise<LaunchOptions | void> {}\n\n  /**\n   * After the browser has launched.\n   *\n   * Note: Don't assume that there will only be a single browser instance during the lifecycle of a plugin.\n   * It's possible that `pupeeteer.launch` will be  called multiple times and more than one browser created.\n   * In order to make the plugins as stateless as possible don't store a reference to the browser instance\n   * in the plugin but rather consider alternatives.\n   *\n   * E.g. when using `onPageCreated` you can get a browser reference by using `page.browser()`.\n   *\n   * Alternatively you could expose a class method that takes a browser instance as a parameter to work with:\n   *\n   * ```es6\n   * const fancyPlugin = require('puppeteer-extra-plugin-fancy')()\n   * puppeteer.use(fancyPlugin)\n   * const browser = await puppeteer.launch()\n   * await fancyPlugin.killBrowser(browser)\n   * ```\n   *\n   * @param  browser - The `puppeteer` or `playwright` browser instance.\n   *\n   * @example\n   * async afterLaunch (browser, opts) {\n   *   this.debug('browser has been launched', opts.options)\n   * }\n   */\n  async afterLaunch(browser: Browser, launchContext: LaunchContext) {}\n\n  /**\n   * Before connecting to an existing browser instance.\n   *\n   * Can be used to modify the puppeteer/playwright connect options by modifying or returning them.\n   *\n   * Plugins using this method will be called in sequence to each\n   * be able to update the launch options.\n   *\n   * @param options - Puppeteer/playwright connect options\n   */\n  async beforeConnect(\n    options: ConnectOptions\n  ): Promise<ConnectOptions | void> {}\n\n  /**\n   * After connecting to an existing browser instance.\n   *\n   * > Note: Don't assume that there will only be a single browser instance during the lifecycle of a plugin.\n   *\n   * @param browser - The `puppeteer` or playwright browser instance.\n   *\n   */\n  async afterConnect(browser: Browser, launchContext: LaunchContext) {}\n\n  /**\n   * Called when a browser instance is available.\n   *\n   * This applies to both `launch` and `connect`.\n   *\n   * Convenience method created for plugins that need access to a browser instance\n   * and don't mind if it has been created through `launch` or `connect`.\n   *\n   * > Note: Don't assume that there will only be a single browser instance during the lifecycle of a plugin.\n   *\n   * @param browser - The `puppeteer` or `playwright` browser instance.\n   */\n  async onBrowser(browser: Browser, launchContext: LaunchContext) {}\n\n  /**\n   * Before a new browser context is created.\n   *\n   * Note: Currently only triggered by `playwright`, as puppeteer's usage of context is very lackluster.\n   *\n   * Plugins using this method will be called in sequence to each\n   * be able to update the context options.\n   *\n   * @see https://github.com/microsoft/playwright/blob/master/docs/api.md#browsernewcontextoptions\n   *\n   * @param options - Playwright browser context options\n   * @param browser - Playwright browser\n   */\n  async beforeContext(\n    options: Playwright.BrowserContextOptions,\n    browser: Playwright.Browser\n  ): Promise<Playwright.BrowserContextOptions | void> {}\n\n  /**\n   * After a new browser context has been created.\n   *\n   * Note: `playwright` specific.\n   *\n   * @param  options - Playwright browser context options\n   * @param  context - Playwright browser context\n   */\n  async onContextCreated(\n    context: Playwright.BrowserContext,\n    options: Playwright.BrowserContextOptions\n  ) {}\n\n  /**\n   * Called when a page has been created.\n   *\n   * The event will also fire for popup pages.\n   *\n   * @see https://playwright.dev/#version=v1.3.0&path=docs%2Fapi.md&q=event-page\n   * @see https://pptr.dev/#?product=Puppeteer&version=main&show=api-event-targetcreated\n   *\n   * @param  {Puppeteer.Page|Playwright.Page} page\n   * @example\n   * async onPageCreated (page) {\n   *   let ua = await page.browser().userAgent()\n   *   if (this.opts.stripHeadless) {\n   *     ua = ua.replace('HeadlessChrome/', 'Chrome/')\n   *   }\n   *   this.debug('new ua', ua)\n   *   await page.setUserAgent(ua)\n   * }\n   */\n  async onPageCreated(page: Page) {}\n\n  /**\n   * Called when a page has been closed.\n   *\n   */\n  async onPageClose(page: Page) {}\n\n  /**\n   * Called when a worker has been created.\n   *\n   * This is a unified event for dedicated, service and shared workers.\n   */\n  async onWorkerCreated(worker: Puppeteer.Worker | Playwright.Worker) {}\n\n  /**\n   * Called when a browser context has been closed.\n   *\n   * Note: `playwright` specific.\n   *\n   */\n  async onContextClose(context: Playwright.BrowserContext) {}\n\n  /**\n   * Called when the browser got disconnected.\n   *\n   * This might happen because of one of the following:\n   * - The browser is closed or crashed\n   * - The `browser.disconnect` method was called\n   *\n   * @param browser - The `puppeteer` or `playwright` browser instance.\n   */\n  async onDisconnected(browser: Browser) {}\n}\n\n/**\n * AutomationExtraPlugin - Meant to be used as a base class and it's methods overridden.\n *\n * Implements all `PluginLifecycleMethods`.\n *\n * @class AutomationExtraPlugin\n * @extends {PluginLifecycleMethods}\n * @example\n *   class Plugin extends AutomationExtraPlugin {\n *     static id = 'foobar'\n *     constructor(opts = {}) {\n *       super(opts)\n *     }\n *\n *     async beforeLaunch(options) {\n *       options.headless = false\n *       return options\n *     }\n *   }\n */\nexport abstract class AutomationExtraPlugin<\n  Opts = PluginOptions\n> extends PluginLifecycleMethods {\n  /** @private */\n  ['constructor']: typeof AutomationExtraPlugin\n  /** @private */\n  private _debugBase: Debugger\n  /** @private */\n  private _opts: Opts\n\n  /**\n   * Plugin id/name (required)\n   *\n   * Convention:\n   * - Package: `automation-extra-plugin-anonymize-ua`\n   * - Name: `anonymize-ua`\n   *\n   * @example\n   * static id = 'anonymize-ua';\n   * // or\n   * static get id() {\n   *   return 'anonymize-ua'\n   * }\n   */\n  static id = 'base-plugin'\n\n  /**\n   * @private\n   */\n  private _env: LauncherEnv | undefined\n\n  constructor(opts?: NestedPartial<Opts>) {\n    super()\n    this._debugBase = debug(`automation-extra-plugin:base:${this.id}`)\n    this._opts = merge(this.defaults, opts || {}, mergeOptions)\n    // this.env = new LauncherEnv()\n    this._debugBase('Initialized.')\n  }\n\n  /**\n   * Access the static id property of the Plugin in an instance.\n   *\n   * @example\n   * static id = 'anonymize-ua';\n   * @private\n   */\n  get id() {\n    if (this.constructor.id === 'base-plugin') {\n      throw new Error('Plugin must override \"id\"') // If you encountered this: Add `static id = 'foobar'` to your class\n    }\n    return this.constructor.id\n  }\n  /**\n   * Backwards compatibility, use a `static id` property instead.\n   * @private\n   */\n  get name() {\n    return this.id\n  }\n\n  /** Unified Page methods for Playwright & Puppeteer */\n  public shim(page: Page): PageShim\n  public shim(obj: unknown): unknown {\n    if (this.env.isPage(obj)) {\n      return new PageShim(this.env, obj)\n    }\n    throw new Error(`Unsupported shim: (isPage: ${this.env.isPage(obj)})`)\n  }\n\n  /**\n   * Plugin defaults (optional).\n   *\n   * If defined will be ([deep-](https://github.com/TehShrike/deepmerge))merged with the (optional) user supplied options (supplied during plugin instantiation).\n   *\n   * The result of merging defaults with user supplied options can be accessed through `this.opts`.\n   *\n   * @see [[opts]]\n   *\n   * @example\n   * get defaults () {\n   *   return {\n   *     stripHeadless: true,\n   *     makeWindows: true,\n   *     customFn: null\n   *   }\n   * }\n   *\n   * // Users can overwrite plugin defaults during instantiation:\n   * puppeteer.use(require('puppeteer-extra-plugin-foobar')({ makeWindows: false }))\n   */\n  get defaults(): Opts {\n    return {} as Opts\n  }\n\n  /**\n   * Plugin requirements (optional).\n   *\n   * Signal certain plugin requirements to the base class and the user.\n   *\n   * Currently supported:\n   * - `launch`\n   *   - If the plugin only supports locally created browser instances (no `puppeteer.connect()`),\n   *     will output a warning to the user.\n   * - `headful`\n   *   - If the plugin doesn't work in `headless: true` mode,\n   *     will output a warning to the user.\n   * - `runLast`\n   *   - In case the plugin prefers to run after the others.\n   *     Useful when the plugin needs data from others.\n   *\n   * @note\n   * The plugin code will still be executed, only a warning will be shown to the user.\n   *\n   * @example\n   * get requirements () {\n   *   return new Set(['runLast', 'dataFromPlugins'])\n   * }\n   */\n  get requirements(): PluginRequirements {\n    return new Set([])\n  }\n\n  /**\n   * Plugin filter statements (optional).\n   *\n   * Filter this plugin from being called depending on the environment.\n   *\n   * @note\n   * `include` or `exclude` are mutually exclusive, use one or the other.\n   *\n   * @example\n   * get filter() {\n   *   return {\n   *     include: ['playwright:chromium', 'puppeteer:chromium']\n   *   }\n   * }\n   */\n  get filter(): Filter | undefined {\n    return\n  }\n\n  /**\n   * Plugin dependencies (optional).\n   *\n   * Missing plugins will be required() by automation-extra.\n   *\n   * @note\n   * Look into using `plugins` instead if you want to avoid dynamic imports.\n   *\n   * @example\n   * // Will ensure the 'puppeteer-extra-plugin-user-preferences' plugin is loaded.\n   * get dependencies () {\n   *   return new Set(['user-preferences'])\n   * }\n   *\n   * // Will load `user-preferences` plugin and pass `{ beCool: true }` as opts\n   * get dependencies () {\n   *   return new Map([['user-preferences', { beCool: true }]])\n   * }\n   *\n   */\n  get dependencies(): PluginDependencies {\n    return new Set([])\n  }\n\n  /**\n   * Add additional plugins (optional).\n   *\n   * Expects an array of AutomationExtraPlugin instances, not classes.\n   * This is intended to be used by \"meta\" plugins that use other plugins behind the scenes.\n   *\n   * The benefit over using `dependencies` is that this doesn't use the framework for dynamic imports,\n   * but requires explicit imports which bundlers like webkit handle much better.\n   *\n   * Missing plugins listed here will be added at the start of `launch` or `connect` events.\n   */\n  get plugins(): MinimalPlugin[] {\n    return []\n  }\n\n  /**\n   * Access the plugin options (usually the `defaults` merged with user defined options)\n   *\n   * To skip the auto-merging of defaults with user supplied opts don't define a `defaults`\n   * property and set the `this._opts` Object in your plugin constructor directly.\n   *\n   * @see [[defaults]]\n   *\n   * @example\n   * get defaults () { return { foo: \"bar\" } }\n   *\n   * async onPageCreated (page) {\n   *   this.debug(this.opts.foo) // => bar\n   * }\n   */\n  get opts(): Opts {\n    return this._opts\n  }\n\n  /**\n   *  Convenience debug logger based on the [debug] module.\n   *  Will automatically namespace the logging output to the plugin package name.\n   *  [debug]: https://www.npmjs.com/package/debug\n   *\n   *  ```bash\n   *  # toggle output using environment variables\n   *  DEBUG=automation-extra-plugin:<plugin_id> node foo.js\n   *  # to debug all the things:\n   *  DEBUG=automation-extra,automation-extra-plugin:* node foo.js\n   *  ```\n   *\n   * @example\n   * this.debug('hello world')\n   * // will output e.g. 'automation-extra-plugin:anonymize-ua hello world'\n   */\n  get debug(): Debugger {\n    return debug(`automation-extra-plugin:${this.id}`)\n  }\n\n  /**\n   * Contains info regarding the launcher environment the plugin runs in\n   * @see LauncherEnv\n   */\n  get env(): LauncherEnv {\n    if (!this._env) {\n      throw new Error(\n        'Launcher env not available yet, you need to register the plugin before using it.'\n      )\n    }\n    return this._env\n  }\n\n  /** @private */\n  set env(env: LauncherEnv) {\n    this._env = env\n  }\n\n  /**\n   * @private\n   */\n  get _isAutomationExtraPlugin() {\n    return true\n  }\n}\n\nexport type SupportedDrivers = 'playwright' | 'puppeteer'\nexport type BrowserEngines = 'chromium' | 'firefox' | 'webkit'\n\n/**\n * TypeGuards: They allow differentiating between different objects and types.\n *\n * Type guards work by discriminating against properties only found in that specific type.\n * This is especially useful when used with TypeScript as it improves type safety.\n *\n * @class TypeGuards\n * @abstract\n */\nexport class TypeGuards {\n  /**\n   * Type guard, will make TypeScript understand which type we're working with.\n   * @param obj - The object to test\n   * @returns {boolean}\n   */\n  isPage(obj: any): obj is Puppeteer.Page | Playwright.Page {\n    return 'goto' in obj && 'url' in obj\n  }\n  /**\n   * Type guard, will make TypeScript understand which type we're working with.\n   * @param obj - The object to test\n   * @returns {boolean}\n   */\n  isBrowser(obj: any): obj is Puppeteer.Browser | Playwright.Browser {\n    return 'newPage' in obj && 'close' in obj\n  }\n  /**\n   * Type guard, will make TypeScript understand which type we're working with.\n   * @param obj - The object to test\n   * @returns {boolean}\n   */\n  isPuppeteerPage(obj: any): obj is Puppeteer.Page {\n    return 'setUserAgent' in (obj as Puppeteer.Page)\n  }\n  /**\n   * Type guard, will make TypeScript understand which type we're working with.\n   * @param obj - The object to test\n   * @returns {boolean}\n   */\n  isPuppeteerBrowser(obj: any): obj is Puppeteer.Browser {\n    return 'createIncognitoBrowserContext' in (obj as Puppeteer.Browser)\n  }\n  /**\n   * Type guard, will make TypeScript understand which type we're working with.\n   * @param obj - The object to test\n   * @returns {boolean}\n   */\n  isPuppeteerBrowserContext(obj: any): obj is Puppeteer.BrowserContext {\n    return 'clearPermissionOverrides' in (obj as Puppeteer.BrowserContext)\n  }\n  /**\n   * Type guard, will make TypeScript understand which type we're working with.\n   * @param obj - The object to test\n   * @returns {boolean}\n   */\n  isPlaywrightPage(obj: any): obj is Playwright.Page {\n    return 'unroute' in (obj as Playwright.Page)\n  }\n  /**\n   * Type guard, will make TypeScript understand which type we're working with.\n   * @param obj - The object to test\n   * @returns {boolean}\n   */\n  isPlaywrightBrowser(obj: any): obj is Playwright.Browser {\n    return 'newContext' in (obj as Playwright.Browser)\n  }\n  /**\n   * Type guard, will make TypeScript understand which type we're working with.\n   * @param obj - The object to test\n   * @returns {boolean}\n   */\n  isPlaywrightBrowserContext(obj: any): obj is Playwright.BrowserContext {\n    return 'addCookies' in (obj as Playwright.BrowserContext)\n  }\n}\n\n/**\n * Stores environment specific info, populated by the launcher.\n * This allows sane plugin development in a multi-browser, multi-driver environment.\n *\n * @class LauncherEnv\n * @extends {TypeGuards}\n */\nexport class LauncherEnv extends TypeGuards {\n  /**\n   * The name of the driver currently in use: `\"playwright\" | \"puppeteer\"`.\n   */\n  public driverName: SupportedDrivers | 'unknown' = 'unknown'\n\n  /**\n   * The name of the browser engine currently in use: `\"chromium\" | \"firefox\" | \"webkit\" | \"unknown\"`.\n   *\n   * Note: With puppeteer the browser will only be known once a browser object is available (after launching or connecting),\n   * as they support defining the browser during `.launch()`.\n   */\n  public browserName: BrowserEngines | 'unknown' = 'unknown'\n\n  /**\n   * EventEmitter for all plugin lifecycle events\n   */\n  public events: TypedEmitter<PluginLifecycleMethods>\n\n  /** @private */\n  constructor(driverName?: SupportedDrivers | 'unknown') {\n    super()\n    if (driverName) {\n      this.driverName = driverName\n    }\n    this.events = new EventEmitter()\n  }\n\n  // Helper methods for convenience\n  /** Check if current driver is puppeteer */\n  get isPuppeteer() {\n    return this.driverName === 'puppeteer'\n  }\n  /** Check if current driver is playwright */\n  get isPlaywright() {\n    return this.driverName === 'playwright'\n  }\n  /** Check if current browser is chrome or chromium */\n  get isChromium() {\n    return this.browserName === 'chromium'\n  }\n  /** Check if current browser is firefox */\n  get isFirefox() {\n    return this.browserName === 'firefox'\n  }\n  /** Check if current browser is webkit */\n  get isWebkit() {\n    return this.browserName === 'webkit'\n  }\n  /** Check if current browser is known */\n  get isBrowserKnown() {\n    return this.browserName !== 'unknown'\n  }\n}\n\n/**\n * Can be converted to JSON\n * @private\n */\ntype Serializable = {}\n\n/**\n * Cache per-page cdp sessions\n * @private\n */\nconst cdpSessionCache = new WeakMap<Page, CDPSession>()\n\nexport type CDPSession = Pick<ProtocolConnectionBase, 'send' | 'on'>\n\n/**\n * Unified Page methods for Playwright & Puppeteer.\n * They support common actions through a single API.\n *\n * @class PageShim\n */\nexport class PageShim {\n  private unsupportedShimError: Error\n\n  constructor(private env: LauncherEnv, private page: Page) {\n    this.unsupportedShimError = new Error(\n      `Unsupported shim: ${this.env.driverName}/${this.env.browserName}`\n    )\n  }\n\n  /**\n   * Adds a script which would be evaluated in one of the following scenarios:\n   *\n   * Whenever the page is navigated.\n   * Whenever the child frame is attached or navigated. In this case, the script is evaluated in the context of the newly attached frame.\n   *\n   * The script is evaluated after the document was created but before any of its scripts were run.\n   *\n   * @see\n   * **Playwright:** `addInitScript`\n   * **Puppeteer:** `evaluateOnNewDocument`\n   */\n  async addScript(script: string | Function, arg?: Serializable) {\n    if (this.env.isPuppeteerPage(this.page)) {\n      return this.page.evaluateOnNewDocument(script as any, arg as any)\n    }\n    if (this.env.isPlaywrightPage(this.page)) {\n      return this.page.addInitScript(script, arg)\n    }\n    throw this.unsupportedShimError\n  }\n\n  /**\n   * Chromium browsers only: Return a fully typed CDP session.\n   *\n   * @see https://playwright.dev/docs/api/class-cdpsession/\n   * @see https://pptr.dev/#?product=Puppeteer&version=v7.0.4&show=api-class-cdpsession\n   */\n  async getCDPSession() {\n    if (this.env.isBrowserKnown && !this.env.isChromium) {\n      throw new Error(\n        'CDP sessions are only available for chromium based browsers.'\n      )\n    }\n    const session = cdpSessionCache.get(this.page)\n    if (session) {\n      return session\n    }\n\n    const createSession = () => {\n      if (this.env.isPuppeteerPage(this.page)) {\n        // In puppeteer we can re-use the existing connection,\n        // I haven't found a way to do that in playwright yet\n        return (this.page as any)._client\n        // return this.page.target().createCDPSession()\n      }\n      if (this.env.isPlaywrightPage(this.page)) {\n        return (this.page.context() as Playwright.ChromiumBrowserContext).newCDPSession(\n          this.page\n        )\n      }\n      throw this.unsupportedShimError\n    }\n    const newSession: unknown = await createSession()\n    cdpSessionCache.set(this.page, newSession as CDPSession)\n    return newSession as CDPSession\n  }\n}\n"],"names":["isPlainObject","EventEmitter"],"mappings":"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"}